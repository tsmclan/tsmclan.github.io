<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<link type="image/x-icon" rel="shortcut icon" href="/favicon.ico" />
<link href="/_assets/font-awesome.css" rel="stylesheet"/>
<link href="/_assets/prismjs.css" rel="stylesheet" />
<link href="/_assets/markdown.css" rel="stylesheet" />
<script src="/_assets/prism.js"></script>
<!-- NOTE1: revise the close tag of this header when releasing the html document -->
<!-- NOTE2: insert script for enabling MathJax when releasing the html document -->
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    TeX: { equationNumbers: { autoNumber: "AMS" } },
    tex2jax: {inlineMath: [["$","$"]]}
  });
</script> -->
<script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/3.0.5/es5/tex-mml-chtml.js"></script>
<!-- <script type="text/javascript" async src="/MathJax/MathJax.js?config=TeX-MML-AM_CHTML"></script> --></p>
<!-- Step 3: uncomment the following lines for enabling toggle-toc script -->

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script>
$(document).ready(function(){
  $(".toc-toggle").click(function(){
    $('body').toggleClass('with-toc');
  });
});
</script>

<p><title>Software Engineering</title>
<!-- Step 1.1: uncomment the next line when revising the head tag in Step 1 -->
<body class="with-toc"><article class="markdown-body"></p>
<h1 id="early-drafts-on-software-engineering-2019-2020">Early drafts on Software Engineering (2019-2020)<a id="home"></a><a class="headerlink" href="#early-drafts-on-software-engineering-2019-2020" title="Permanent link"></a></h1>
<p>
2020-03-29 (周日) 22:30&nbsp;
出处：<b>tsmc 原创</b>&nbsp;
作者：<b>陈荣</b>&nbsp;
</p>

<!-- Navigation section -->

<!-- http://web.archive.org/web/20130929055652/http://fontawesome.io/ v3.2.1-->

<!-- tp://localhost/faicons.html -->

<!-- <I class="icon-compass"></I> icon-compass -->

<ul id="breadcrumb">
<li><a href="#home"><span class="icon icon-home"> </span> &nbsp;</a></li>
<li><a href="#icsoc"><span class="icon icon-twitter"> </span> ICSOC</a></li>
<li><a href="#msr"><span class="icon icon-comment-alt"> </span> MSR</a></li>
<li><a href="#fn:1"><span class="icon icon-bookmark-empty"> </span> Private Ref.</a></li>
<li><a href="/pap/allreferences.html#chc"><span class="icon icon-bookmark-empty"> </span> Topic Ref.</a></li>
<li><a href="#his"><span class="icon icon-rss"> </span> Work History</a></li>
</ul>

<p><br></p>
<!-- Table of Content (TOC) toggle on jquery.min.js -->

<p><button name="toc-toggle" class="toc-toggle"><span>Table of Contents</span></button>
<div id="toc">
<ul>
<li class="toc-h1 toc-active"><a href="#">HOME</a></li>
<li class="toc-h1"><a href="#ml4me"> Machine Learning for Model Extraction</a></li>
<li class="toc-h1"><a href="#msr"> Mining Software Repositories</a></li>
<li class="toc-h1"><a href="#tofi"> Train of ideas</a></li>
<li class="toc-h1"><a href="#seke"> SEKE&lsquo;2018</a></li>
<li class="toc-h2"><a href="#ijseke"> IJSEKE18</a></li>
</ul>
</div>
<br></p>
<p>Scheduling is a fundamental domain of the operations research field, putting together many different methods such as linear programming, evolutionary algorithms and simulation- based optimization to solve a wide range of problems sharing some common elements and features such as job processing time, deadlines, and precedence constraints between tasks.</p>
<p><a href="https://cszhangtao.github.io">Tao Zhang&rsquo;s Publications</a> make use of data mining and AI techniques to solve problems in bug triage and mining software repositories.</p>
<p>Machine learning of software artefacts is an emerging area of interaction between the machine learning (ML) and software analysis (SA) communities. Increased productivity in software engineering hinges on the creation of new adaptive, scalable tools that can analyse large and continuously changing software systems. For example: agile software development using continuous integration and delivery can require new documentation models, static analyses, proofs and tests of millions of lines of code every 24 hours. These needs are being addressed by new SA techniques based on machine learning, such as learning-based software testing, invariant generation or code synthesis.</p>
<p style='text-align: right'><em>-- from <a href="https://link.springer.com/book/10.1007%2F978-3-319-96562-8">Machine Learning for Dynamic Software Analysis: Potentials and Limits</a></em></p>

<h2 id="machine-learning-for-model-extraction">Machine Learning for Model Extraction <a id="ml4me"></a><a class="headerlink" href="#machine-learning-for-model-extraction" title="Permanent link"></a></h2>
<p><blockquote>
    <span>A major hurdle in applying supervised learning is often the significant effort of labelling both the training and evaluation data, in order to induce a function f with sufficient quality. Fortunately, in a software engineering context, there are situations where the system under learning (SUL) itself can act as a qualified teacher that can label both training and evaluation examples.</span>
</blockquote></p>
<ul>
<li>How can one learn truly high-level models of code that capture design intentions such as decomposition, sharing and hierarchy?</li>
<li>What level of abstraction should be captured by learning and how can one combine powerful continuous and discrete methods for machine learning to support model analysis?</li>
<li>How can one model and efficiently learn software systems that are not sufficiently documented, and are subject to constant change?</li>
<li>How can one best model uncertainty and partial information arising from observing software systems that are too large to be completely learned? Can continuous learning methods be used interpolate missing information?</li>
<li>Continuous mathematical models of learning are widely used in ML but largely unused in SA, since most analysis algorithms are not applicable. Is there a way to harness continuous learning without losing symbolic analysis methods?</li>
</ul>
<h2 id="learning-based-testing-lbt">Learning-based testing (LBT) <a id="lbt"></a><a class="headerlink" href="#learning-based-testing-lbt" title="Permanent link"></a></h2>
<p>The basic idea of LBT is to use <em>active machine learning</em> to dynamically generate (online) an efficient test suite for a system under test (SUT). This active learning process is used to infer, or reverse engineer, a sequence of increasingly accurate models $M_0$, $M_1$, . . . of the SUT.</p>
<p>A randomised approach to equivalence checking not only provides a generic solution, it also supports a probabilistic approach to model convergence and coverage metrics, which seems to work reasonably well in practise. Furthermore, randomised equivalence check- ing allows us to introduce non-uniform probability distributions on the choice of test cases. This opens up the possibility to apply risk-based testing. It also connects LBT with the very extensive theory of PAC (probably approximately correct) learning theory (ref).</p>
<p><a href="http://www.csc.kth.se/~karlm/lbtest/">LBTest</a> is a new open source tool for black-box requirements testing of embedded and reactive systems based on the principles of LBT.</p>
<p>Concolic testing (a portmanteau of concrete and symbolic) is a hybrid software verification technique that performs symbolic execution, a classical technique that treats program variables as symbolic variables, along a concrete execution (testing on particular inputs) path. Symbolic execution is used in conjunction with an automated theorem prover or constraint solver based on constraint logic programming to generate new concrete inputs (test cases) with the aim of maximizing code coverage. Its main focus is finding bugs in real-world software, rather than demonstrating program correctness. <a href="https://github.com/TrustAI/DeepConcolic">DeepConcolic: Concolic Testing for Deep Neural Networks</a></p>
<h2 id="mining-software-repositories">Mining Software Repositories <a id="msr"></a><a class="headerlink" href="#mining-software-repositories" title="Permanent link"></a></h2>
<p><strong>Defect prediction</strong> can assist the quality assurance teams to reasonably allocate the limited testing resources by detecting the potentially defective software modules (such as classes, files, components) before releasing the software product. Thus, effective defect prediction can save testing cost and improve software quality. The majority of existing researches leverages various machine learning techniques to build defect prediction methods. We use <markg>F-measure</markg>, <markg>G-measure</markg>, Matthews Correlation Coefficient (<markg>MCC</markg>) and Area Under the ROC Curve (<markg>AUC</markg>) to measure the performance.</p>
<p>Many software companies spend most of the money in fixing the bugs. Large software projects have bug repository that collects all the information related to bugs. In bug repository, each software bug has a bug report (BR). The BR consists of textual information regarding the bug and updates related to status of bug fixing. Developers often examine BRs in software repositories to get hints for fixing the bugs.</p>
<p>Zhang&rsquo;s IEEE Software paper <sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>  presents a systematic study on the difference in BRs for desktop software and mobile apps hosted in GitHub. To help researchers reproduce our work, we publicly share all data sets and analysis results at <a class="magiclink magiclink-github magiclink-repository" href="https://github.com/PolyUCJC317/IEEE-Software" title="GitHub Repository: PolyUCJC317/IEEE-Software">PolyUCJC317/IEEE-Software</a>.</p>
<p>Zhang&rsquo;s ICPC paper <sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup> proposes a new approach to enrich bug reports. The concept “enrich” means adding more detailed information (e.g., the reason why a bug appears) to a given bug report. The reason <markp>why the short reports delay the fixing time</markp> may lie in the lack of informative contents in bug reports. Hooimeijer and Weimer reported that the lack of resource often causes the delay of bug fixing [14] <sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup>. According to the results of the questionnaire on bug report quality [15] <sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup>, Bettenburg et al. find that time delay is due to the absent information for bug reports. </p>
<p>In large-scale distributed systems, node crashes are inevitable, and can happen at any time. As such, distributed systems are usually designed to be resilient to these node crashes via various crash recovery mechanisms, such as write-ahead logging in HBase and hinted handoffs in Cassandra. However, faults in crash recovery mechanisms and their implementations can introduce intricate crash recovery bugs, and lead to severe consequences.
In this paper, we present CREB, the most comprehensive study on 103 Crash REcovery Bugs from four popular open-source distributed systems, including ZooKeeper, Hadoop MapReduce, Cassandra and HBase. For all the studied bugs, we analyze their root causes, triggering conditions, bug impacts and fixing. Through this study, we obtain many interesting findings that can open up new research directions for combating crash recovery bugs.</p>
<h2 id="train-of-ideas">Train of ideas <a id="tofi"></a><a class="headerlink" href="#train-of-ideas" title="Permanent link"></a></h2>
<h4 id="api-method-recommendation-without-worrying-about-the-task-api-knowledge-gap">API Method Recommendation without Worrying about the Task-API Knowledge Gap<a class="headerlink" href="#api-method-recommendation-without-worrying-about-the-task-api-knowledge-gap" title="Permanent link"></a></h4>
<p>Important role of API <code>==&gt;</code> complete programming task efficiently <code>==&gt;</code> however, not easy to be familiar with all APIs in a large lib. <code>==&gt;</code> This situation can be referred to as “known unknowns”. </p>
<p>do not even know which API is worth learning (i.e., “unknown unknowns”) <code>==&gt;</code> a possible solution is to use IR technique to obtain some candidate APIs whose documentation is similar to the query <code>==&gt;</code> However, this solution may not work well due to the lexical gap between the query and the API documentation. <code>==&gt;</code> explain lexical gap with an example</p>
<p>Recently, word embeddings can capture the semantic meaning of different words <code>==&gt;</code> Ye et al. [49] leveraged word embedding to bridge the lexical gap <code>==&gt;</code> However, by replicating their study, we observe two major problems, as listed below. <code>==&gt;</code> problem 1 and 2 <code>==&gt;</code> “task-API knowledge gap” &ndash; mismatches between a task description and the API documentation, and our observation is also consistent with previous studies </p>
<p>To bridge this task-API knowledge gap, we conduct a survey with developers <code>==&gt;</code> Thus, SO is often exploited as a bridge between the programming task and the needed API(s) <code>==&gt;</code>  This is possible because &hellip;</p>
<p>Inspired by this information seeking process, we propose an automatic approach named BIKER (Bi-Information source based KnowledgE Recommendation) which leverages both SO posts and API documentation to recommend APIs for a programming task. <code>==&gt;</code> To bridge the knowledge gap, BIKER &hellip; <code>==&gt;</code> Since these questions and the query share similar purposes, the APIs mentioned in the questions are also likely to resolve the programming task in the query. <code>==&gt;</code> In this way, narrow down the search space <code>==&gt;</code> To rank the relevance of a candidate API &hellip; <code>==&gt;</code> In this way, balance the API information from &hellip; perspective <code>==&gt;</code> To bridge the lexical gap &hellip;, we follow Ye et al. [49] to use &hellip; <code>==&gt;</code> In addition to recom- mending APIs, BIKER also summarizes &hellip;</p>
<p>To evaluate BIKER, we manually selected 413 questions from SO that are seeking APIs to resolve programming tasks and labelled the ground-truth APIs for these questions based on their accepted answers.</p>
<h4 id="measuring-program-comprehension-a-large-scale-field-study-with-professionals">Measuring Program Comprehension: A Large-Scale Field Study with Professionals<a class="headerlink" href="#measuring-program-comprehension-a-large-scale-field-study-with-professionals" title="Permanent link"></a></h4>
<p>During software development and maintenance, developers spend a considerable amount of time on program comprehension activities. Previous studies show that program comprehension <markp>takes up</markp> (consumes | occupies | spend? | uses up] <markp>around 50%</markp> (as much as half) of a developer’s time.
Previous/Prior studies show that program comprehension is an essential and time-consuming activity in software maintenance.</p>
<p>However, most of these studies are performed <markp>in a controlled setting</markp>(in a artificial setting | in a realistic setting | ), or with a small number of participants, and investigate the program comprehension activities only within the IDEs. 
(1) several conclusions are based on anecdotal evidences [13], [15], [63], instead of empirical experiments on developers; ; (2) most prior studies are performed under controlled experiment with artificial setting, making difficult to generalize the results, e.g., [26]; (3) most prior studies involve a small number of participants (e.g., Ko et al.’s study has 10 participants [26], while Minelli et al.’s study has 18 participants [36]), and most of the participants are not professionals; (4) most prior studies only investigate program comprehension activities that occur within IDEs [26], [36].</p>
<p>Different from several other previously-proposed ~ | Relative to prior studies | </p>
<h4 id="deephunter-an-automated-fuzz-testing-framework-for-hunting-potential-defects-of-general-purpose-dnns">DeepHunter - an automated fuzz testing framework for hunting potential defects of general-purpose DNNs.<a class="headerlink" href="#deephunter-an-automated-fuzz-testing-framework-for-hunting-potential-defects-of-general-purpose-dnns" title="Permanent link"></a></h4>
<p>To be scalable to- wards practical-sized DNNs, DeepHunter maintains multiple tests in a batch, and prioritizes the tests selection based on active feedback. </p>
<p>However, due to the fundamental difference between traditional and DNN based software, traditional fuzzing elements could not be directly applied to DNN fuzzing. For example, the mutations and the feedback are all different in many ways. </p>
<p>&ldquo;while there was much anecdotal evidence there was little hard fact&rdquo;</p>
<p>TensorFuzz: Coverage Guided Fuzzing for Neural Networks
<a class="magiclink magiclink-github magiclink-repository" href="https://github.com/brain-research/tensorfuzz" title="GitHub Repository: brain-research/tensorfuzz">brain-research/tensorfuzz</a></p>
<h2 id="real-time-edge-user-allocation-under-budget-and-time-constraints-in-mobile-edge-computing">Real-Time Edge User Allocation under Budget and Time Constraints in Mobile Edge Computing  <a id="icsoc"></a><a class="headerlink" href="#real-time-edge-user-allocation-under-budget-and-time-constraints-in-mobile-edge-computing" title="Permanent link"></a></h2>
<h4 id="icsoc2019"><a href="https://icsoc-laas.fr/cfp-2-2/">ICSOC2019: %</a><a class="headerlink" href="#icsoc2019" title="Permanent link"></a></h4>
<p>The 17th International Conference on Service-Oriented Computing (ICSOC), October 28-31, 2019. Toulouse, France</p>
<p><i class="icon-calendar"></i>&nbsp;<strong><a href="https://www.conftool.com/icsoc2018">Submission</a></strong> Login with tsmc /crat509601</p>
<p><strong>Length.</strong> Papers should be formatted according to <a href="http://www.springer.com/computer/lncs/lncs+authors?SGWID=0-40209-0-0-0">Springer’s LNCS Formatting Guidelines</a>. Submissions must be in English and not exceed <markp>15 pages</markp> including all references and figures. All papers must be submitted electronically in PDF to the <a href="https://www.conftool.com/icsoc2018">Conference Submission System</a>.</p>
<div class="pageBottom"><span class="bNum">1</span><span class="bTit">Abstraction</span><a id="icsoc1a"></a><span class="tBot"><a href="#qrs" target="_self" > Top</a> </span></div>

<p>(204 words)
Mobile edge computing is a novel paradigm for low network latency and great scalability, which engages end-devices – such as wearables, sensors or smart phones – in the act of collecting various types of data and oﬄoading datastream-ing tasks to the nearby edge servers. In this study, we address the edge user allocation problem with time windows (EUATW) to determine the optimal resources management for a service running on hired edge servers and end-devices located within the geographical vicinity of the edge servers for some time periods. The challenge is thus to minimize the number of hired edge servers and maximize the number of managed end-devices while ensuring the quality of ser-vice, which is subject to the budget on computing resource and the colocation relationship changing with the dynamic entering and leaving of end-devices. Formulate the EUATW problem as the max flow matching on a bipartite graph, we study the complexity of its offline version and then then propose several heuris-tics for the online version which exploit the spatial and temporal knowledge ac-quired over time or provided by the service. Extensive experiments with real-world and synthetic datasets show that our approach signiﬁcantly outperforms the other competing approaches.</p>
<p>We address the <a href="/pap/se/19icsoc/p19euatw.html"><strong>edge user allocation problem with time windows (EUATW)</strong></a></p>
<h2 id="software-defect-prediction-using-reinforced-machine-learning-technique">Software Defect Prediction Using Reinforced Machine Learning Technique <a id="qrs"></a><a class="headerlink" href="#software-defect-prediction-using-reinforced-machine-learning-technique" title="Permanent link"></a></h2>
<h4 id="qrs2019"><a href="https://qrs19.techconf.org">QRS2019: %</a><a class="headerlink" href="#qrs2019" title="Permanent link"></a></h4>
<p>The 19th QRS conference will be held from 22-26 July, 2019 in Sofia, Bulgaria.</p>
<p><i class="icon-calendar"></i>&nbsp;<strong><a href="http://banana.utdallas.edu/qrs2019/start/www/Regular-Paper/">Submission</a></strong> Login with tsmc /crat509601</p>
<p><strong>Length.</strong> Submit original papers (not published or considered elsewhere) with a maximum of <markp>12 pages</markp> (context and references). Include the title of the paper, and the name and affiliation of each author, a 150-word abstract, and up to 6 keywords. </p>
<div class="pageBottom"><span class="bNum">1</span><span class="bTit">Abstraction</span><a id="seke1a"></a><span class="tBot"><a href="#qrs" target="_self" > Top</a> </span></div>

<p>Almost all software fault prediction studies use metrics and faulty data of previous software release to build fault prediction models, which is called supervised learning approaches.</p>
<div class="pageBottom"><span class="bNum">2</span><span class="bTit">Introduction</span><a id="seke1a"></a><span class="tBot"><a href="#qrs" target="_self" > Top</a> </span></div>

<p>Almost all software fault prediction studies use metrics and faulty data of previous software release to build fault prediction models, which is called supervised learning approaches.</p>
<p><a href="http://promise.site.uottawa.ca/SERepository/datasets-page.html">Promise Software Engineering Repository</a></p>
<p>SIGSOFT &lsquo;08/FSE-16 <a href="https://dl.acm.org/citation.cfm?id=1453146">What makes a good bug report?</a></p>
<p>TSE 2010 <a href="https://ieeexplore.ieee.org/abstract/document/5487527">What makes a good bug report?</a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=1958887">&ldquo;Not my bug!&rdquo; and other reasons for software bug report reassignments</a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=1321639">Modeling bug report quality</a></p>
<p>Can You Explain That, Better? Comprehensible Text Analytics for SE Applications <a href="https://github.com/ai-se/LDA_FFT">All our data, experiments, scripts</a></p>
<h2 id="weighted-data-set-reduction-for-automatic-bug-triaging">Weighted Data Set Reduction for Automatic Bug Triaging  <a id="seke"></a><a class="headerlink" href="#weighted-data-set-reduction-for-automatic-bug-triaging" title="Permanent link"></a></h2>
<h4 id="seke2018"><a href="http://ksiresearchorg.ipage.com/seke/seke18.html">SEKE2018: %</a><a class="headerlink" href="#seke2018" title="Permanent link"></a></h4>
<p>29th International Conference on Software Engineering and Knowledge Engineering
the Wyndham Pittsburgh University Center, Pittsburgh, USA. 
from July 5 to July 7, 2017.</p>
<p><i class="icon-calendar"></i>&nbsp;<strong><a href="https://www.easychair.org/conferences/?conf=seke2018">Submission</a></strong> Login with tsmc /crat509601</p>
<p><i class="icon-folder-open"> D:\wk18\tsmc\pap\se\18SEKE</i>
<i class="icon-download-alt"></i> <a href="/../pap/se/18SEKE/seke_wmm_2.4.doc">seke_wmm_2.4.doc</a></p>
<p><strong>Length.</strong> Manuscript must include a 200-word abstract and no more than <markp>6 pages</markp> of double column formatted Manuscript for Conference Proceedings (include figures and references but exclude copyright form). </p>
<div class="pageBottom"><span class="bNum">1</span><span class="bTit">Abstraction</span><a id="seke1a"></a><span class="tBot"><a href="#seke" target="_self" > Top</a> </span></div>

<p>Despite the great potential to save the labor cost of developers, automated bug triaging as a text classification problem has not been thoroughly investigated on long descriptions, which are informative but often noisy. In this paper an effective bug triage technique is proposed to build a high quality set of bug data by removing the noisy and non-informative bug reports while assigning new bugs to an appropriate developers. The proposed technique &ndash; weighted data set reduction  &ndash; is built upon three feature selection algorithms and four instances selection algorithms with intention to recommend the bug and to automatically assign it more accurately even with noisy bug descriptions. Several experiments are conducted and the experimental results show that the reduced training sets by the proposed approach can achieve better accuracy in several cases, about 2-3% on average better than the original ones.</p>
<p>Bug Triaging; Bug Reports; Bug Assignment; Machine Learning; Text Classiﬁcation; Industrial Scale</p>
<div class="pageBottom"><span class="bNum">2</span><span class="bTit">Introduction</span><a id="seke2i"></a><span class="tBot"><a href="#seke" target="_self" > Top</a> </span></div>

<p>With the increasing scale and complexity of open source software projects, many open source software projects adopt bug tracking systems ( e.g. , Buzilla[2], JIRA[3], mantis[4] ) to maintain the huge information about the reported bugs (Xia et al., 2013), . The bug tracking system not only provides a feedback channel of open source software projects to end user, allowing developers to identify software defects or the suggestions of end user as early as possible. In addition, The bug tracking system also could coordinate the work between developers, and document the solution of software defects, which could provide more facilitate to software maintenance.</p>
<p>Once a new bug report is submitted to the bug tracking system, a triager who is responsible for managing bug reports can read this report to understand the details of the given bug, and assigning suitable developers for the bug report(i.e., bug triaging). However, new submitted bugs are all manual assigned at present, which is time-consuming and labor-intensive. On the one hand, every day, a large number of bug reports are submitted to bug repositories. For example, Eclipse bug repository receives an average of 91 new bug reports each day. Obviously, processing multitude of bug reports places a heavy burden on triagers. On the other hand, The development and maintenance of open source software projects often require a large number of developers. For Eclipse bug repository, more than 1800 developers are involved in bug fixes. If we use artificial to bug triaging, it could consume a lot of time and human resources.</p>
<p>In order to solve the above-mentioned problems, an automated mechanism to assign fixer of bug reports would be much preferable to augment productivity. G.C.Murphy[20] first proposed the idea of automatic bug triaging. They solve the problem of bug triaging as a text classification problem, use the Naive Bayes (NB) Classification algorithm to experiment on Eclipse data sets to predict the right developers. But the training set scale is large. Classification method either failure or training time is very long. Anvik[14,15] tested the training effects of multiple classification algorithms on multiple data sets. They proposed turn bug triaging issues into semi-automate. But the quality of the data set itself is too low. Jeong[21] proposed tossing graph[24] method. However, in order to improve the accuracy of the classification, both of them basically makes improvements in text categorization or forecasting result. But ignored the problem of the data set itself.</p>
<h2 id="a-novel-approach-to-task-publishing-in-a-crowdsourcing-environment">A Novel Approach to Task Publishing In a Crowdsourcing Environment  <a id="ijseke"></a><a class="headerlink" href="#a-novel-approach-to-task-publishing-in-a-crowdsourcing-environment" title="Permanent link"></a></h2>
<h5 id="ijseke-ccf-c-login-with-rchencs-chen222"><a href="http://ijseke.edmgr.com/">IJSEKE: CCF C</a> Login with rchen.cs / chen222<a class="headerlink" href="#ijseke-ccf-c-login-with-rchencs-chen222" title="Permanent link"></a></h5>
<p><i class="icon-folder-open"> D:\wk18\tsmc\pap\se\IJSEKE18</i>
<i class="icon-download-alt"></i> <a href="/../pap/se/IJSEKE18/IJSEKE-twj-v1.6CR.docx">IJSEKE-twj-v1.6CR.docx</a></p>
<p><strong>Length.</strong> Manuscript must include a 200-word abstract and no more than <markp>6 pages</markp> of double column formatted Manuscript for Conference Proceedings (include figures and references but exclude copyright form). </p>
<div class="pageBottom"><span class="bNum">1</span><span class="bTit">Abstraction</span><a id="uic1a"></a><span class="tBot"><a href="#ijseke" target="_self" > Top</a> </span></div>

<p>In recent years, crowdsourcing has gradually become a promising way of using netizens to accomplish tiny tasks, or even complex works through crowdsourcing workflows that decompose them into tiny ones to publish sequentially on the crowdsourcing platforms. One of the significant challenges in this process is how to determine the parameters for task publishing. Still some technique applied constraint solving to select the optimal tasks parameters so that the total cost of completing all tasks is minimized. However, experimental results show that computational complexity makes these tools unsuitable for solving large-scale problems because of its excessive execution time. Taking into account the real-time requirements of crowdsourcing, this study uses a heuristic algorithm with four heuristic strategies to solve the problem in order to reduce execution time. The experiment results also show that the proposed heuristic strategies produce good quality approximate solutions in an acceptable timeframe.</p>
<h2 id="work-history">Work History <a id="his"></a><a class="headerlink" href="#work-history" title="Permanent link"></a></h2>
<ul>
<li>2018-02-18 (周日) 20:22 新建md文件</li>
<li>2018-03-13 (周二) 08:15 wxx文章修改</li>
<li>2018-03-14 (周三) 14:55 twy文章修改</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>[Zou et. al., 2011] W. Zou, Y. Hu, J. Xuan, and H. Jiang. Towards training set reduction for bug triage. In proceedings of the 35th Annual IEEE International Computer Software and Applications Conference, Jul. 2011, pp. 576–581.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>[Zhang et. al., 2018] Tao Zhang, Jiachi Chen, Xiapu Luo, and Tao Li. Bug Reports for Desktop Software and Mobile Apps in GitHub: What is the Difference?. IEEE Software, Accepted to appear, 2018 ( Invited to the Journal First Session of the 33rd IEEE International Conference on Software Maintenance and Evolution (ICSME)).&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>[Zhang et. al., 2017] Tao Zhang, Jiachi Chen, He Jiang, Xiapu Luo, and Xin Xia. Bug Report Enrichment with Application of Automated Fixer Recommendation. In Proc. of the 25th IEEE International Conference on Program Comprehension (ICPC&lsquo;17), pp.230-240, 2017.&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>P. Hooimeijer and W. Weimer, “Modeling bug report quality,” in ASE’07, 2007, pp. 34–43.&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>N. Bettenburg, S. Just, A. Schro ̈ter, C. Weiss, R. Premraj, and T. Z-immermann, “What makes a good bug report?” in FSE ’08, 2008, pp.308–318.&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Amel Bennaceur, Reiner Hähnle, Karl Meinke (eds). Machine Learning for Dynamic Software Analysis: Potentials and Limits. International Dagstuhl Seminar 16172, Dagstuhl Castle, Germany, April 24-27, 2016, Revised Papers&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
</ol>
</div></article></body></html>